// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity >=0.8.0;
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

import "./ERC721MinterPauser.sol";

 import "./interface/IERC721Royalty.sol";


contract StartfiRoyaltyNFT is ERC721MinterPauser, IERC721Royalty {
    using SafeMath for uint256;
        using Counters for Counters.Counter;

    mapping (uint256 => address) private _issuer;
    mapping (uint256 => mapping (address=>Base) ) private _issuerPercentage;
     Counters.Counter private _tokenIdTracker;

    constructor(string memory name, string memory symbol, string memory baseTokenURI) ERC721MinterPauser (   name,  symbol,   baseTokenURI){}

    function mintWithRoyalty(address to,uint8 share,uint8 base) external virtual {
        require(hasRole(MINTER_ROLE, _msgSender()), "ERC721MinterPauser: must have minter role to mint");
        // We cannot just use balanceOf to create the new tokenId because tokens
        // can be burned (destroyed), so we need a separate counter.
        _supportRoyalty(_tokenIdTracker.current(),  to,   share,  base);
        _mint(to, _tokenIdTracker.current());
        _tokenIdTracker.increment();
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE`.
     */
        function mint(address to) public virtual {
        require(hasRole(MINTER_ROLE, _msgSender()), "ERC721MinterPauser: must have minter role to mint");

        // We cannot just use balanceOf to create the new tokenId because tokens
        // can be burned (destroyed), so we need a separate counter.
        _mint(to, _tokenIdTracker.current());
        _tokenIdTracker.increment();
    }
 // 3.5 is 35 share and 10 base 
   struct Base{
        uint8 share;
        uint8 sharebase;
    }
  
   
    function _supportRoyalty( uint256 _tokenId,address issuer, uint8 share,uint8 base) private {
        _issuer[_tokenId]=issuer;
        _issuerPercentage[_tokenId][issuer]= Base(share,base);
    }
function royaltyInfo(uint256 _tokenId, uint256 _value) external view  override returns (address issuer, uint256 _royaltyAmount){
     issuer = _issuer[_tokenId];
    if(issuer!=address(0)){
     Base memory _base=_issuerPercentage[_tokenId][issuer];
        _royaltyAmount = _value.mul(uint256 (_base.share)).div(100).div(uint256(_base.sharebase));
    }
}
// 0x2a55205a
    function supportsInterface(bytes4 interfaceId) public view  virtual override  returns (bool) {
        return interfaceId == type(IERC721Royalty).interfaceId;
    }

}
